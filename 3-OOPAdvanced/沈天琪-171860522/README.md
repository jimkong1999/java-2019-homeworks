![UML图](https://raw.githubusercontent.com/Price1999a/java-2019-homeworks/master/3-OOPAdvanced/%E6%B2%88%E5%A4%A9%E7%90%AA-171860522/srcForMD/UMLhw3.png)

由这张图中我们可以清晰地看到我们代码的设计方式。

一共由9个类构成了作业3所需程序。

具体而言，我们首先有一个战场类，即**BattleField**类，
这是一个**16*16**的**int**数组,其中存放的实际上就是对象**id**，
这就要求所有id是唯一的，这就是为什么我设计了**Involved**类。

在本例中战场是唯一的，不是分割的，这就适合单例模式用于实例化战场，
在这里我简单运用了**static**的相关语法。
我将战场上所有可能出现的存在——空格、葫芦娃、蛇精、爷爷、小怪
、蝎精都视作为对象。除空格外，他们都继承于空格。
这样，所有这些基类、派生类都共享一个战场，
即这些类包含了一个**BattleField**对象。

在我看来，每一个生物都要移动。空格虽然不是动物动不了，
为了减少代码量，我将**walkto**方法放在了**Being**类中。

特别的，蝎精是小怪们的指挥官，熟读兵书了解阵型，他又有法力，
他就有能力带着小怪们瞬间改换阵型，这一方法就是**orderMonsters**方法，
这一法术直接作用于战场，端的是方便无比。
（实际上，
当前如此设计的原因在于要编写一个指挥**Monster**们寻路以部阵的算法目前有一些复杂，
当前来看似乎没有必要，所以现在他们的移动方式是跃迁：一起进入第四维度
——即在地图上擦除自身，再在合适的位置进入战场——即把自己的位置写回战场）

最终**Involved**类集中了所有参战者们，参战者们又共享一个战场。
这样**Involved**类包含了所有基类和派生类，另外，对于**Scorpion 
Elder Snack**这些类而言，这又有类似代理的样式：
**Involved**中的一些方法就是其中包含的类的方法的封装。
另外有对**Involved**的说明，不包含显式的**Huluwa**类与**Monster**类的原因在于：
这二者没有相较于**Being**独特的方法，暂时无需如此操作
（虽然很明显未来几乎必须要在此基础上扩充）
